{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"MkDocs Material Boilerplate - Starter Kit Details \u00b6 Read more \ud83d\udc49 Documentation - MkDocs Material Boilerplate Quick start \u00b6 git clone https://github.com/peaceiris/mkdocs-material-boilerplate.git cd mkdocs-material-boilerplate pipenv sync --dev pipenv shell inv serve --config-file mkdocs-sample.yml Links \u00b6 mkdocs/mkdocs: Project documentation with Markdown - GitHub squidfunk/mkdocs-material: A Material Design theme for MkDocs License \u00b6 MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY About Maintainer \u00b6 peaceiris Homepage","title":"Home"},{"location":"#details","text":"Read more \ud83d\udc49 Documentation - MkDocs Material Boilerplate","title":"Details"},{"location":"#quick_start","text":"git clone https://github.com/peaceiris/mkdocs-material-boilerplate.git cd mkdocs-material-boilerplate pipenv sync --dev pipenv shell inv serve --config-file mkdocs-sample.yml","title":"Quick start"},{"location":"#links","text":"mkdocs/mkdocs: Project documentation with Markdown - GitHub squidfunk/mkdocs-material: A Material Design theme for MkDocs","title":"Links"},{"location":"#license","text":"MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY","title":"License"},{"location":"#about_maintainer","text":"peaceiris Homepage","title":"About Maintainer"},{"location":"license/","text":"License \u00b6 MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY","title":"License"},{"location":"license/#license","text":"MIT License The graduate cap icon made by Freepik from www.flaticon.com is licensed by CC 3.0 BY","title":"License"},{"location":"extensions/janitor/","text":"Janitor \u00b6 Custom cleanup methods \u00b6 Other garbage collection implementations such as Maid don't give you a choice with how you clean up objects. You can either give a function, a connection, an Instance, or a table with a Destroy method. Janitor allows you to specify how you clean up objects, so you can cancel a Tween when the Janitor is cleaned up. Promise Support \u00b6 Janitor supports adding Promises to it natively, which will then cancel if the Janitor is cleaned up. This makes Janitor the only library of its kind with support for this implementation of Promises. Instances linking \u00b6 Janitor's LinkToInstance method allows you to cleanup the Janitor when a linked Instance is destroyed. This allows you to execute behavior on destruction as well as cleanup objects quickly. Links \u00b6 Site Github DevForum","title":"Janitor"},{"location":"extensions/janitor/#janitor","text":"","title":"Janitor"},{"location":"extensions/janitor/#custom_cleanup_methods","text":"Other garbage collection implementations such as Maid don't give you a choice with how you clean up objects. You can either give a function, a connection, an Instance, or a table with a Destroy method. Janitor allows you to specify how you clean up objects, so you can cancel a Tween when the Janitor is cleaned up.","title":"Custom cleanup methods"},{"location":"extensions/janitor/#promise_support","text":"Janitor supports adding Promises to it natively, which will then cancel if the Janitor is cleaned up. This makes Janitor the only library of its kind with support for this implementation of Promises.","title":"Promise Support"},{"location":"extensions/janitor/#instances_linking","text":"Janitor's LinkToInstance method allows you to cleanup the Janitor when a linked Instance is destroyed. This allows you to execute behavior on destruction as well as cleanup objects quickly.","title":"Instances linking"},{"location":"extensions/janitor/#links","text":"Site Github DevForum","title":"Links"},{"location":"extensions/simplepath/","text":"SimplePath \u00b6 SimplePath is an open-source pathfinding module that gives you the ability to quickly create a pathfinding script for humanoids and non-humanoids with just a few lines of code. Pathfinding is done using Roblox's PathfindingService. This module works by using a \"repetitive\" approach to pathfinding. The pathfinding agent moves a more efficient path when computed repetitively instead of just once. Part of the reason why is because computing the path once doesn't guarantee that the agent reaches the goal as expected. Taking the repetitive approach accounts for any obstructions or obstacles blocking the path at the current time. This guarantees that the agent will reach its goal no matter what as long as it's traversable within the scope of PathfindingService. Although you can still use SimplePath normally, it is strongly suggested that you take a repetitive approach to pathfinding as this was the primary concept kept in mind during the development of this module. However, in some scenarios, it might be better to compute the path just once. For example, if the agent does not interact with moving objects, you should consider changing the structure of your pathfinding code by reducing the number of repetitions between path computations to improve performance. Links \u00b6 Site Github DevForum Roblox","title":"Simple Path"},{"location":"extensions/simplepath/#simplepath","text":"SimplePath is an open-source pathfinding module that gives you the ability to quickly create a pathfinding script for humanoids and non-humanoids with just a few lines of code. Pathfinding is done using Roblox's PathfindingService. This module works by using a \"repetitive\" approach to pathfinding. The pathfinding agent moves a more efficient path when computed repetitively instead of just once. Part of the reason why is because computing the path once doesn't guarantee that the agent reaches the goal as expected. Taking the repetitive approach accounts for any obstructions or obstacles blocking the path at the current time. This guarantees that the agent will reach its goal no matter what as long as it's traversable within the scope of PathfindingService. Although you can still use SimplePath normally, it is strongly suggested that you take a repetitive approach to pathfinding as this was the primary concept kept in mind during the development of this module. However, in some scenarios, it might be better to compute the path just once. For example, if the agent does not interact with moving objects, you should consider changing the structure of your pathfinding code by reducing the number of repetitions between path computations to improve performance.","title":"SimplePath"},{"location":"extensions/simplepath/#links","text":"Site Github DevForum Roblox","title":"Links"},{"location":"guides/start/","text":"This tutorial shows you how you can set up SimplePath and teaches you a basic implementation of the module. Installation \u00b6 Get the module from the Roblox library or get the latest release from GitHub. Note For the purposes of the tutorial, the script assumes the modulescript is in game.ReplicatedStorage ; For security purposes it would be best if placed game.ServerScriptService . After you insert the module to your place, add a new script to game.ServerScriptService and paste the folowing code to start using the module: --Import the module so you can start using it local ServerScriptService = game : GetService ( \"ServerScriptService\" ) local EasyEnemies = require ( ServerScriptService . EasyEnemies ) The next part of the code defines all of the different methods of usage: -- Defining Enemy Settings local enemy_settings = { health = 100 , -- Enemy Health damage = 1 , -- Enemy Base Damage wander = false , -- Enemy Wandering attack_range = 20 , -- Enemy Attack Radius attack_ally = false , -- Enemy Attacking Team Members attack_npcs = true , -- Enemy Attacking Random NPC's attack_players = true , -- Enemy Attacking Players default_animations = { 8972576500 }, -- Enemy Animations should be used for 'Light' Attacks default_functions = { -- Functions for said 'Light' Attacks ^ function ( target ) -- functions pass the target as the first argument automatically print ( target ) end , }, special_animations = { 3 }, -- Enemy Animations should be used for 'Heavy' Attacks special_functions = { -- Functions for said 'Heavy' Attacks ^ function () -- functions pass the target as the first argument automatically print ( 'specialMove' ) end , }, } --Create a new Path using the Dummy local Enemy = EasyEnemies . new ( Dummy , enemy_settings ) Note EasyEnemies.new() is a constructor that creates a new Path and it should only be created once per agent. Method 1: Using Events \u00b6 The following part of the tutorial shows you how you can make a pathfinding script using only events. To make the Dummy move towards the goal, you only need one line of code: Path : Run ( Goal ) Even though this single line of code seems sufficient, there are a few important things to keep in mind. Firstly, if some object comes in-between the path of the Dummy, the Dummy will just stop pathfinding before reaching the goal because Path:Run() is not called a second time to compute the path again. To fix this, you can use the Path.Blocked event and call Path:Run() whenever something blocks the path: --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) The next thing to keep in mind is the position of the goal part. In the case where the goal part is constantly moving, how can you alter the current path of Dummy to make sure that it reaches the exact position of the goal part? You can do this by adding in 2 more events. The Path.WaypointReached event will compute a new Path everytime the Dummy reaches the next waypoint and accounts for a new position of the goal part if it changed. --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) The second event is Path.Error . You can compute a new path every time the target becomes unreachable or the path to the goal is not traversable. For example, if the part is floating in the sky, the Dummy would not be able to reach it and Path.Error fires. --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Your code should look something like this after adding everything in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Info Set Path.Visualize to true before the very first Path:Run() call to see the waypoints. As you can see, the Dummy stops pathfinding after reaching the goal. If you want the Dummy to always follow the goal part even after reaching it, you can simply use the Path.Reached event: --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end ) Method 2: Using Loops \u00b6 In the following tutorial, you will learn how to use SimplePath using loops instead of events. Using SimplePath in a loop is way simpler than using events. You only need 3 lines of code: while true do Path : Run ( Goal ) end Path:Run() does not require a wait because it automatically yields if the maximum time elapsed between consecutive calls are less than Settings.TIME_VARIANCE . If you are using loops, your final code should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end Choosing the right method \u00b6 SimplePath gives you the freedom to code in any method you prefer. You are not limited to the two methods mentioned in this tutorial as they are simply meant to be examples. You can even combine both methods and implement them together at once. It all depends on how you decide to structure your code based on the performance, compatibility, etc. and personal preference.","title":"Getting Started"},{"location":"guides/start/#installation","text":"Get the module from the Roblox library or get the latest release from GitHub. Note For the purposes of the tutorial, the script assumes the modulescript is in game.ReplicatedStorage ; For security purposes it would be best if placed game.ServerScriptService . After you insert the module to your place, add a new script to game.ServerScriptService and paste the folowing code to start using the module: --Import the module so you can start using it local ServerScriptService = game : GetService ( \"ServerScriptService\" ) local EasyEnemies = require ( ServerScriptService . EasyEnemies ) The next part of the code defines all of the different methods of usage: -- Defining Enemy Settings local enemy_settings = { health = 100 , -- Enemy Health damage = 1 , -- Enemy Base Damage wander = false , -- Enemy Wandering attack_range = 20 , -- Enemy Attack Radius attack_ally = false , -- Enemy Attacking Team Members attack_npcs = true , -- Enemy Attacking Random NPC's attack_players = true , -- Enemy Attacking Players default_animations = { 8972576500 }, -- Enemy Animations should be used for 'Light' Attacks default_functions = { -- Functions for said 'Light' Attacks ^ function ( target ) -- functions pass the target as the first argument automatically print ( target ) end , }, special_animations = { 3 }, -- Enemy Animations should be used for 'Heavy' Attacks special_functions = { -- Functions for said 'Heavy' Attacks ^ function () -- functions pass the target as the first argument automatically print ( 'specialMove' ) end , }, } --Create a new Path using the Dummy local Enemy = EasyEnemies . new ( Dummy , enemy_settings ) Note EasyEnemies.new() is a constructor that creates a new Path and it should only be created once per agent.","title":"Installation"},{"location":"guides/start/#method_1_using_events","text":"The following part of the tutorial shows you how you can make a pathfinding script using only events. To make the Dummy move towards the goal, you only need one line of code: Path : Run ( Goal ) Even though this single line of code seems sufficient, there are a few important things to keep in mind. Firstly, if some object comes in-between the path of the Dummy, the Dummy will just stop pathfinding before reaching the goal because Path:Run() is not called a second time to compute the path again. To fix this, you can use the Path.Blocked event and call Path:Run() whenever something blocks the path: --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) The next thing to keep in mind is the position of the goal part. In the case where the goal part is constantly moving, how can you alter the current path of Dummy to make sure that it reaches the exact position of the goal part? You can do this by adding in 2 more events. The Path.WaypointReached event will compute a new Path everytime the Dummy reaches the next waypoint and accounts for a new position of the goal part if it changed. --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) The second event is Path.Error . You can compute a new path every time the target becomes unreachable or the path to the goal is not traversable. For example, if the part is floating in the sky, the Dummy would not be able to reach it and Path.Error fires. --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Your code should look something like this after adding everything in: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true --Dummy knows to compute path again if something blocks the path Path . Blocked : Connect ( function () Path : Run ( Goal ) end ) --If the position of Goal changes at the next waypoint, compute path again Path . WaypointReached : Connect ( function () Path : Run ( Goal ) end ) --Dummmy knows to compute path again if an error occurs Path . Error : Connect ( function ( errorType ) Path : Run ( Goal ) end ) Path : Run ( Goal ) Info Set Path.Visualize to true before the very first Path:Run() call to see the waypoints. As you can see, the Dummy stops pathfinding after reaching the goal. If you want the Dummy to always follow the goal part even after reaching it, you can simply use the Path.Reached event: --Compute a new path every time the Dummy reaches the goal part Path . Reached : Connect ( function () Path : Run ( Goal ) end )","title":"Method 1: Using Events"},{"location":"guides/start/#method_2_using_loops","text":"In the following tutorial, you will learn how to use SimplePath using loops instead of events. Using SimplePath in a loop is way simpler than using events. You only need 3 lines of code: while true do Path : Run ( Goal ) end Path:Run() does not require a wait because it automatically yields if the maximum time elapsed between consecutive calls are less than Settings.TIME_VARIANCE . If you are using loops, your final code should look something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 --Import the module so you can start using it local ServerStorage = game : GetService ( \"ServerStorage\" ) local SimplePath = require ( ServerStorage . SimplePath ) --Define npc local Dummy = workspace . Dummy -- Define a part called \"Goal\" local Goal = workspace . Goal --Create a new Path using the Dummy local Path = SimplePath . new ( Dummy ) --Helps to visualize the path Path . Visualize = true while true do Path : Run ( Goal ) end","title":"Method 2: Using Loops"},{"location":"guides/start/#choosing_the_right_method","text":"SimplePath gives you the freedom to code in any method you prefer. You are not limited to the two methods mentioned in this tutorial as they are simply meant to be examples. You can even combine both methods and implement them together at once. It all depends on how you decide to structure your code based on the performance, compatibility, etc. and personal preference.","title":"Choosing the right method"},{"location":"hosting-and-deployment/combinations/","text":"Hosting and Deployment \u00b6 GitHub Pages and GitHub \u00b6 Host source code on GitHub. Build and deploy with: mkdocs gh-deploy GitHub Actions GitLab Pages and GitLab \u00b6 Host source code on GitLab. Build and deploy with GitLab CI/CD. Netlify \u00b6 Host source code on: GitHub GitLab BitBucket Build and deploy with Netlify. AWS Amplify Console \u00b6 Host source code on: GitHub GitLab BitBucket AWS CodeCommit Build and deploy with AWS Amplify Console.","title":"Combinations"},{"location":"hosting-and-deployment/combinations/#hosting_and_deployment","text":"","title":"Hosting and Deployment"},{"location":"hosting-and-deployment/combinations/#github_pages_and_github","text":"Host source code on GitHub. Build and deploy with: mkdocs gh-deploy GitHub Actions","title":"GitHub Pages and GitHub"},{"location":"hosting-and-deployment/combinations/#gitlab_pages_and_gitlab","text":"Host source code on GitLab. Build and deploy with GitLab CI/CD.","title":"GitLab Pages and GitLab"},{"location":"hosting-and-deployment/combinations/#netlify","text":"Host source code on: GitHub GitLab BitBucket Build and deploy with Netlify.","title":"Netlify"},{"location":"hosting-and-deployment/combinations/#aws_amplify_console","text":"Host source code on: GitHub GitLab BitBucket AWS CodeCommit Build and deploy with AWS Amplify Console.","title":"AWS Amplify Console"}]}